{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-09-15T00:07:01.028802+00:00",
  "repo": "squarooticus/draft-krose-multicast-security",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "114 draft deadline",
      "description": "",
      "color": "d4c5f9"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU5MDk4NTU3OTc=",
      "title": "Congestion Control in Multicast Transport Properties section",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/issues/1",
      "state": "OPEN",
      "author": "GrumpyOldTroll",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "GrumpyOldTroll"
      ],
      "labels": [],
      "body": "Write up a brief explanation of congestion control in multicast (with mention of security and trust of receivers), include a reference to [RFC 8085, Section 4](https://datatracker.ietf.org/doc/html/rfc8085#section-4) and maybe to https://www.youtube.com/watch?v=rzvVHYtSn4s&t=6m24s / https://datatracker.ietf.org/meeting/97/materials/slides-97-mboned-draft-jholland-cb-assisted-cc\r\n(tried to assign to myself, but no such button...)",
      "createdAt": "2021-06-02T20:24:15Z",
      "updatedAt": "2021-06-07T17:11:06Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU5MDk4NzIyMzA=",
      "title": "Discuss burden on servers of stream confidentiality",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/issues/2",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Conceptually, you can make all streams look the same: LBR is 500 Kb/s with identical packet sizes for all videos; HBR is 20Mb/s with identical packet sizes for all videos. This might be absurd in reality, but it's a possibility.",
      "createdAt": "2021-06-02T20:48:45Z",
      "updatedAt": "2021-07-13T14:43:49Z",
      "closedAt": "2021-07-13T14:43:49Z",
      "comments": []
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU5MDk4NzQ0OTE=",
      "title": "Too dismissive of replay in Authenticity and Integrity section",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/issues/3",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "last paragraph of section 4.1 maybe should talk about replay mitigation and loss detection, which is probably doable in both ambi and tesla.",
      "createdAt": "2021-06-02T20:52:02Z",
      "updatedAt": "2021-06-04T16:29:44Z",
      "closedAt": "2021-06-04T16:25:11Z",
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "OWNER",
          "body": "Unless I'm misunderstanding something about TESLA (which is entirely possible since I've never read the doc completely through), it doesn't have any structure in which duplication/replay/reordering would be detectable within a time interval, nor indeed anything at all for loss/deletion.",
          "createdAt": "2021-06-04T16:29:44Z",
          "updatedAt": "2021-06-04T16:29:44Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU5MjE2Njk5Mjk=",
      "title": "Forward secrecy elaboration",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/issues/6",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Do we need to think more about, and then describe, a model in which forward secrecy is achieved through key management? For instance, obviously a static key protecting the payload which is protected by a rotating key which is itself protected by long-term keys provides no forward secrecy for the content.",
      "createdAt": "2021-06-15T18:13:33Z",
      "updatedAt": "2021-07-13T14:44:15Z",
      "closedAt": "2021-07-13T14:44:15Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "COLLABORATOR",
          "body": "I think a rotating ephemeral key that's required to be discarded after rotation is the same as what TLS provides, right?  As long as the earlier keys aren't recoverable after rotation I think you get the same forward secrecy?\r\n\r\nBut we probably do need to think about it and describe it some.\r\n\r\nI was originally thinking extending AMBI to define the parameters for data packet encryption should work, and then maybe adding a key identifier to the manifest.  Since you raised the concern that it shouldn't be possible to start from the (S,G) )and find the key, I've been thinking that the key itself definitely shouldn't be provided from inside the AMBI metadata, but also perhaps not even the uri (and that would be another out of band thing the app would need to know in order to get started).\r\n\r\nIt's making me think maybe it's not as easy as I was hoping, and I'm not quite sure whether it should be a separate protocol or whether it should be squeezed inside AMBI.  But I think providing a key id in the manifest is useful, which pushes me toward \"integrated with AMBI\".",
          "createdAt": "2021-06-21T22:31:21Z",
          "updatedAt": "2021-06-21T22:31:21Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU5NDAyMDA0NzQ=",
      "title": "Suggestion: Section about threat actors?",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/issues/7",
      "state": "OPEN",
      "author": "GrumpyOldTroll",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I suspect it would be useful to organize the threats in terms of threat actors, the actions they can take with their consequences if unaddressed, and what countermeasures mitigate those actions and how.\r\n\r\nI think this will make it clearer, but even more I hope that this can be a useful place to collect feedback and other concerns.",
      "createdAt": "2021-07-08T20:34:14Z",
      "updatedAt": "2021-07-08T20:34:14Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU5NDAyMzMzMDI=",
      "title": "k-anonymity to on-path observers?",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/issues/8",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think multicast has some privacy benefits relative to unicast that aren't yet captured here but should probably be articulated.\r\n\r\nFor unicast, an on-path observer has access to metadata like total amount of data, count of packets, port & protocol, and source address of traffic sent to and from each client IP, which can be tied to the address assigned to a location at a time by the AS that owns the IP.\r\n\r\nFor multicast traffic, an on-path observer would have much more limited information.  An observer would need knowledge of topology to know the downstream locations from a given network location, but still would have no way to know who has subscribed.",
      "createdAt": "2021-07-08T21:24:23Z",
      "updatedAt": "2021-07-13T14:44:22Z",
      "closedAt": "2021-07-13T14:44:22Z",
      "comments": []
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU5NDE2MzgyNjI=",
      "title": "Amplification attack vector?",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/issues/9",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "OWNER",
      "assignees": [
        "GrumpyOldTroll"
      ],
      "labels": [],
      "body": "You had this:\r\n\r\n> TODO: maybe some mention that higher-level protocols can provide reliability (e.g. 5740 (norm)/5775 (alc) and/or flute(6726)/fcast(6968) that use alc, plus draft-pardue-quic-http-mcast), but this may introduce different risks from spoofing if per-packet authenticity is not provided.  For example, in an application with unicast recovery for a reliable object that's constructed out of 1k packets, injecting a single spoofed packet amplifies by 1k * number of receivers, if they all recover the whole reliable object.  Also: determine whether this mention belongs in this section--maybe better as a ref to a different section here?\r\n\r\nI don't understand what is being suggested here. How does injection cause all the clients to generate recovery requests?",
      "createdAt": "2021-07-12T03:45:29Z",
      "updatedAt": "2021-07-13T14:45:11Z",
      "closedAt": "2021-07-13T14:45:11Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "COLLABORATOR",
          "body": "Here I'm talking about mechanisms that build a block out of unauthenticated packets, and then the block gets authenticated as a whole.\r\n\r\nIf injecting a packet causes a successful build of a block that fails authentication, then users would fall back to another method to recover the block, for example fetching it with unicast.\r\n\r\nSo when the superbowl is on and you're using 1.4MB segments (composed of ~1k packets each), then someone injects a spoofed packet that causes a mistaken build of the segment, everybody has to get that missed segment at the same time and it messes everything up.  By providing per-packet authentication, you can prevent the attempt to construct a block using a bad packet, and thus prevent the invalidating of 999 other packets that had been legitimately received.",
          "createdAt": "2021-07-12T03:52:57Z",
          "updatedAt": "2021-07-12T03:52:57Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "OWNER",
          "body": "Got it.",
          "createdAt": "2021-07-12T03:53:43Z",
          "updatedAt": "2021-07-12T03:53:43Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "OWNER",
          "body": "Right, so it's actually 1.4 MB * number of receivers, not 1 KB (in the case you're talking about).",
          "createdAt": "2021-07-12T03:55:13Z",
          "updatedAt": "2021-07-12T03:55:13Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "COLLABORATOR",
          "body": "1k packets * packet size * number of receivers.  Yes.\r\n\r\nSegments can of course also be bigger, but as an example 1000 packets per segment is not unreasonably low or high.  Probably on the lower side, I guess, but reasonable.",
          "createdAt": "2021-07-12T07:29:43Z",
          "updatedAt": "2021-07-12T07:29:43Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "OWNER",
          "body": "I read \"1k packets\" as \"packets of size 1 KB\". That explains the confusion. Anyway, I think I've covered this in an understandable way without reference to specific numbers, but feel free to reopen this issue if you think otherwise.",
          "createdAt": "2021-07-13T14:45:11Z",
          "updatedAt": "2021-07-13T14:45:11Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU5NDE2NTMzOTE=",
      "title": "TODO: Dangers of manipulation without violating authentication and how to manage this.",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/issues/10",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "OWNER",
      "assignees": [
        "GrumpyOldTroll"
      ],
      "labels": [],
      "body": "I didn't leave myself enough information in this TODO to understand what the actual concern is. Ideas?",
      "createdAt": "2021-07-12T04:18:42Z",
      "updatedAt": "2021-07-13T14:45:25Z",
      "closedAt": "2021-07-13T14:45:25Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "COLLABORATOR",
          "body": "I assume this is talking about fields that are not authenticated?  Like maybe IP length with evil UDP options appended?  Or I guess dropping packets?  Not sure what else isn't authenticated, but since this isn't specific to AMBI maybe there's header fields not covered by TESLA in some cases or something?\r\nAlso possibly things like discovery?\r\n\r\nNothing else coming to mind.  I don't recall talking about this in particular...",
          "createdAt": "2021-07-12T05:23:50Z",
          "updatedAt": "2021-07-12T05:23:50Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWU5NTMzMjE2MzQ=",
      "title": "Peeking at unauthenticated data",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/issues/11",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Address the issue of being able to look at data prior to authentication. This is a problem that is probably unavoidable in any symmetric cryptosystem in which more than two parties have access to the key.",
      "createdAt": "2021-07-26T22:01:43Z",
      "updatedAt": "2021-08-06T16:46:14Z",
      "closedAt": "2021-08-06T16:46:14Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "I_kwDOFhM1zs49zpw-",
      "title": "Address binding of request to response",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/issues/12",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "squarooticus"
      ],
      "labels": [
        "114 draft deadline"
      ],
      "body": "Comment from EKR on secdispatch:\r\n> S 3.2.\r\n>\r\n>    The Web security model requires that content be authenticated\r\n>    cryptographically.  In the context of unicast transport security,\r\n>    authentication means that content is known to have originated from\r\n>    the trusted peer, something that is typically enforced via a\r\n>    cryptographic authentication tag:\r\n>\r\n> This is true, but I think misses an important property of Web\r\n> authentication, which is the binding between the request and\r\n> the response. I.e., the property is not just that the message\r\n> came from the peer but also that it came in response to a given\r\n> request.\r\n",
      "createdAt": "2021-10-27T04:03:01Z",
      "updatedAt": "2022-07-11T21:53:34Z",
      "closedAt": "2022-07-11T21:53:34Z",
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "OWNER",
          "body": "@GrumpyOldTroll The PR isn't ready yet, but I have to run for now and I wanted you to look at what I've started to put together. Comments welcome on the above commit.",
          "createdAt": "2021-11-03T22:54:26Z",
          "updatedAt": "2021-11-03T22:54:26Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOFhM1zs4_sWUB",
      "title": "Scaling and privacy considerations are linked",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/issues/14",
      "state": "OPEN",
      "author": "squarooticus",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Summary: scalability is a prerequisite for growth in high-volume traffic. So it's going to happen one way or the other. There is a good argument to be made that bringing it into the light via SDO action, with attention paid to privacy, is going to produce better outcomes than the alternative, which will be a proprietary/closed solution.",
      "createdAt": "2021-12-01T16:05:32Z",
      "updatedAt": "2021-12-01T16:05:32Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 15,
      "id": "I_kwDOFhM1zs5Nb8XS",
      "title": "Referer equivalent?",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/issues/15",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "OWNER",
      "assignees": [
        "squarooticus"
      ],
      "labels": [
        "114 draft deadline"
      ],
      "body": "Need to solve the problem of akarnai.com telling you to pull from an official Akamai (S,G), which can be foiled by Referer checks in the unicast web.\r\n\r\n> e.g. if a different legitimate quic connection says someone else's quic multicast stream is theirs, that's maybe a problem worth protecting against. Maybe we need a periodic asymmetric challenge? I'm thinking send a public key on the multicast channel and in the unicast channels send an individualized MAC signed with the private key and verify it with the public key, so that in addition to validating that the unicast server knows the contents of the multicast packets via the hashes it supplies, the multicast stream provides a way for the client to validate that the unicast stream is authorized to use it for data transport via proof they know the private key corresponding to the public key that arrived on the multicast channel. Note this doesn't prevent unauthorized receipt of multicast data packets, but does prevent a quic server from lying when claiming a multicast data channel belongs to it, preventing legit receivers from consuming it.\r\n> alternatively, can the multicast channel just periodically say what domain name is expected for the quic connection and get the same crypto guarantee of a proper sender via the domain's cert, which was already checked on the unicast channel?)",
      "createdAt": "2022-07-08T15:31:54Z",
      "updatedAt": "2022-07-11T22:22:49Z",
      "closedAt": "2022-07-11T22:22:48Z",
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "OWNER",
          "body": "Resolved by 75bd7e9.",
          "createdAt": "2022-07-11T22:22:48Z",
          "updatedAt": "2022-07-11T22:22:48Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOFhM1zs5Nnq1N",
      "title": "Referrer checks vs. origin checks?",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/issues/17",
      "state": "OPEN",
      "author": "GrumpyOldTroll",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The new referrer checks section from (https://github.com/squarooticus/draft-krose-multicast-security/commit/75bd7e9b801da1dbbbd95d570dab51f7bdbb43c4) talks about server-side referer checks, but I'm not sure this is as relevant as providing a mechanism to ensure the origin policy (particularly the same-origin policy) can be enforced on the client side.\r\n\r\nMaybe we need references about it too?\r\n- https://datatracker.ietf.org/doc/html/rfc6454 (maybe section 3 specifically, but maybe the whole doc)\r\n- https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\r\n- https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\r\n\r\nAlso maybe it's worth walking thru an example somehow--if a connection established via evil.example.com is able to tell clients to receive and interpret legitimate multicast traffic being sent by good.example.com, then unless there are mechanisms ensuring the multicast traffic is tied to the good.example.com origin, the content from bad.example.com would be able to circumvent the same-origin policy wrt that content.",
      "createdAt": "2022-07-12T15:45:20Z",
      "updatedAt": "2022-08-05T16:01:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "OWNER",
          "body": "I'll update before I-D submission reopens in two weeks.",
          "createdAt": "2022-07-12T16:10:49Z",
          "updatedAt": "2022-07-12T16:10:49Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "OWNER",
          "body": "Think about adding the hostname to the key derivation to cryptographically link the channel data to the hostname the client intends to connect to. @GrumpyOldTroll ",
          "createdAt": "2022-08-05T15:18:23Z",
          "updatedAt": "2022-08-05T15:18:23Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "OWNER",
          "body": "Want hostname to bind content to the same *entity* as the unicast connection. Could include port, (S,G) IPs, but those aren't necessary to prevent cross-origin leeching because incorrect data wouldn't pass the integrity check.",
          "createdAt": "2022-08-05T16:01:19Z",
          "updatedAt": "2022-08-05T16:01:19Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0NjYyMDgxNzQ3",
      "title": "Tweaks",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/pull/4",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-04T21:52:06Z",
      "updatedAt": "2022-07-12T12:34:21Z",
      "baseRepository": "squarooticus/draft-krose-multicast-security",
      "baseRefName": "master",
      "baseRefOid": "fef7651a77a637816b7ed8a2e23dc15d429d1abc",
      "headRepository": "squarooticus/draft-krose-multicast-security",
      "headRefName": "tweaks",
      "headRefOid": "de9516f8478ffeaca33f1073c73343dc6590926e",
      "closedAt": "2021-06-07T17:00:35Z",
      "mergedAt": "2021-06-07T17:00:35Z",
      "mergedBy": "squarooticus",
      "mergeCommit": {
        "oid": "117fc25120648c527889cc66eab69b344a8ff6f7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0NjcwMTYzMTk4",
      "title": "minor editorial suggestions",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/pull/5",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-15T07:53:54Z",
      "updatedAt": "2021-06-15T14:01:13Z",
      "baseRepository": "squarooticus/draft-krose-multicast-security",
      "baseRefName": "master",
      "baseRefOid": "557f222c62e13a02b5a09ff75b208db52aad77e5",
      "headRepository": "squarooticus/draft-krose-multicast-security",
      "headRefName": "minor-edits2",
      "headRefOid": "45fa8d067ade9b60284d39d6271acb0743533d2d",
      "closedAt": "2021-06-15T14:01:13Z",
      "mergedAt": "2021-06-15T14:01:13Z",
      "mergedBy": "squarooticus",
      "mergeCommit": {
        "oid": "6fa200bac444b62e6c18096d43515e167a3923c9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MDUwMjQ5",
          "commit": {
            "abbreviatedOid": "45fa8d0"
          },
          "author": "squarooticus",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-15T14:01:02Z",
          "updatedAt": "2021-06-15T14:01:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDOFhM1zs4uEK-i",
      "title": "Beef up the privacy analysis",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/pull/13",
      "state": "MERGED",
      "author": "squarooticus",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": " * Add more text to the privacy section to bolster the case for the\r\n   benefits of k-anonymity over unicast for large simultaneous download\r\n   events.",
      "createdAt": "2021-11-03T21:53:41Z",
      "updatedAt": "2022-07-12T12:34:11Z",
      "baseRepository": "squarooticus/draft-krose-multicast-security",
      "baseRefName": "master",
      "baseRefOid": "f41baa6d40e61773dc45445b0f5f8b60cdf09655",
      "headRepository": "squarooticus/draft-krose-multicast-security",
      "headRefName": "beef-up-privacy-analysis",
      "headRefOid": "dbd8d182efaaf23541b9128501972a93ca05ba94",
      "closedAt": "2021-11-03T22:41:29Z",
      "mergedAt": "2021-11-03T22:41:29Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "2e3fc269a3b32a5b6e4bcc82c50ec819d7827d31"
      },
      "comments": [
        {
          "author": "brettsheffield",
          "authorAssociation": "NONE",
          "body": "Nice work. I think most people overlook these benefits. The idea that multicast is somehow less secure or private, is quite pervasive, when the opposite is true.",
          "createdAt": "2021-11-03T22:30:35Z",
          "updatedAt": "2021-11-03T22:30:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFhM1zs4vg-Iu",
          "commit": {
            "abbreviatedOid": "dbd8d18"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm. thanks.",
          "createdAt": "2021-11-03T22:38:07Z",
          "updatedAt": "2021-11-03T22:38:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOFhM1zs47OSwk",
      "title": "Add section on request/response binding",
      "url": "https://github.com/squarooticus/draft-krose-multicast-security/pull/16",
      "state": "MERGED",
      "author": "squarooticus",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-07-11T21:52:34Z",
      "updatedAt": "2022-07-12T12:34:08Z",
      "baseRepository": "squarooticus/draft-krose-multicast-security",
      "baseRefName": "master",
      "baseRefOid": "4a4e37b06634d78b5f715b5968af6135c1dd59b8",
      "headRepository": "squarooticus/draft-krose-multicast-security",
      "headRefName": "12-binding-response-to-request",
      "headRefOid": "78967f6eeb9a121d582f85552cb0bd57e17a97c4",
      "closedAt": "2022-07-11T21:53:33Z",
      "mergedAt": "2022-07-11T21:53:33Z",
      "mergedBy": "squarooticus",
      "mergeCommit": {
        "oid": "4f09125f8c54167b238685510f781249917d506b"
      },
      "comments": [],
      "reviews": []
    }
  ]
}